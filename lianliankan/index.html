<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è‹¹æœé£è¿è¿çœ‹</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    
    .game-container {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(255, 255, 255, 0.2);
      padding: 30px;
      width: 100%;
      max-width: 500px;
      text-align: center;
      margin-top: 20px;
    }
    
    h1 {
      font-size: 2.5rem;
      color: #333;
      margin-bottom: 10px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      background: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      background: rgba(255, 255, 255, 0.7);
      padding: 15px;
      border-radius: 15px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff6b6b;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #888;
    }
    
    .game-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
      margin: 20px auto;
      max-width: 400px;
      background: rgba(240, 240, 240, 0.7);
      padding: 15px;
      border-radius: 15px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .tile {
      aspect-ratio: 1;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      transition: all 0.2s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      background: white;
      user-select: none;
    }
    
    .tile:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }
    
    .tile.selected {
      transform: scale(0.9);
      box-shadow: 0 0 0 3px #4CAF50, 0 6px 8px rgba(0, 0, 0, 0.15);
      background: #e8f5e9;
    }
    
    .tile.matched {
      opacity: 0;
      transform: scale(0);
    }
    
    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    button {
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .message {
      margin-top: 20px;
      padding: 15px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.7);
      font-weight: 500;
      min-height: 25px;
    }
    
    .win-message {
      background: linear-gradient(45deg, #43cea2, #185a9d);
      color: white;
      font-size: 1.2rem;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .instructions {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      text-align: left;
      font-size: 0.9rem;
      color: #555;
    }
    
    .instructions h3 {
      margin-bottom: 10px;
      color: #333;
      text-align: center;
    }
    
    .instructions ul {
      padding-left: 20px;
    }
    
    .instructions li {
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>ğŸ è‹¹æœé£è¿è¿çœ‹</h1>
    
    <div class="stats">
      <div class="stat-item">
        <div class="stat-value" id="moves">0</div>
        <div class="stat-label">æ­¥æ•°</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="time">0s</div>
        <div class="stat-label">æ—¶é—´</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="pairs">0</div>
        <div class="stat-label">é…å¯¹</div>
      </div>
    </div>
    
    <div class="game-board" id="gameBoard"></div>
    
    <div class="message" id="message">é€‰æ‹©ä¸¤ä¸ªç›¸åŒçš„å›¾æ ‡è¿›è¡Œæ¶ˆé™¤</div>
    
    <div class="controls">
      <button id="restartBtn">ğŸ”„ é‡æ–°å¼€å§‹</button>
      <button id="hintBtn">ğŸ’¡ æç¤º</button>
    </div>
    
    <div class="instructions">
      <h3>æ¸¸æˆè§„åˆ™</h3>
      <ul>
        <li>ç‚¹å‡»ä¸¤ä¸ªç›¸åŒçš„å›¾æ ‡è¿›è¡ŒåŒ¹é…</li>
        <li>åŒ¹é…çš„è·¯å¾„æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªæ‹è§’</li>
        <li>æ¶ˆé™¤æ‰€æœ‰å›¾æ ‡å³å¯è·èƒœ</li>
        <li>ä½¿ç”¨æç¤ºæŒ‰é’®è·å–å¸®åŠ©</li>
      </ul>
    </div>
  </div>

  <script>
    class LinkGame {
      constructor() {
        this.boardSize = 8;
        this.grid = [];
        this.selectedTile = null;
        this.moves = 0;
        this.time = 0;
        this.pairsFound = 0;
        this.totalPairs = (this.boardSize * this.boardSize) / 2;
        this.gameStarted = false;
        this.timerInterval = null;
        
        this.icons = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸ‡', 'ğŸ“', 'ğŸ‘', 'ğŸ’', 'ğŸ¥', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥­', 'ğŸ¥‘'];
        
        this.init();
      }
      
      init() {
        this.createBoard();
        this.setupEventListeners();
        this.updateStats();
      }
      
      createBoard() {
        const gameBoard = document.getElementById('gameBoard');
        gameBoard.innerHTML = '';
        this.grid = [];
        
        // åˆ›å»ºå›¾æ ‡æ•°ç»„ï¼ˆæ¯ä¸ªå›¾æ ‡å‡ºç°ä¸¤æ¬¡ï¼‰
        let iconsArray = [];
        const iconCount = (this.boardSize * this.boardSize) / 2;
        for (let i = 0; i < iconCount; i++) {
          iconsArray.push(this.icons[i % this.icons.length]);
          iconsArray.push(this.icons[i % this.icons.length]);
        }
        
        // éšæœºæ‰“ä¹±å›¾æ ‡æ•°ç»„
        this.shuffleArray(iconsArray);
        
        // åˆ›å»ºç½‘æ ¼
        for (let row = 0; row < this.boardSize; row++) {
          this.grid[row] = [];
          for (let col = 0; col < this.boardSize; col++) {
            const tileValue = iconsArray.pop();
            this.grid[row][col] = {
              value: tileValue,
              element: null,
              matched: false
            };
            
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.textContent = tileValue;
            tile.dataset.row = row;
            tile.dataset.col = col;
            
            gameBoard.appendChild(tile);
            this.grid[row][col].element = tile;
            
            tile.addEventListener('click', (e) => this.handleTileClick(row, col));
          }
        }
      }
      
      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      
      handleTileClick(row, col) {
        if (!this.gameStarted) {
          this.startTimer();
          this.gameStarted = true;
        }
        
        const tile = this.grid[row][col];
        
        // å¦‚æœå·²ç»åŒ¹é…æˆ–å·²è¢«é€‰ä¸­ï¼Œåˆ™å¿½ç•¥
        if (tile.matched) return;
        
        if (tile.element.classList.contains('selected')) {
          // å–æ¶ˆé€‰æ‹©
          tile.element.classList.remove('selected');
          this.selectedTile = null;
          this.showMessage('å–æ¶ˆé€‰æ‹©');
          return;
        }
        
        if (this.selectedTile === null) {
          // é€‰æ‹©ç¬¬ä¸€ä¸ªå›¾æ ‡
          this.selectedTile = { row, col };
          tile.element.classList.add('selected');
          this.showMessage('å·²é€‰æ‹©ç¬¬ä¸€ä¸ªå›¾æ ‡ï¼Œå†é€‰æ‹©ä¸€ä¸ªç›¸åŒå›¾æ ‡è¿›è¡ŒåŒ¹é…');
        } else {
          // é€‰æ‹©ç¬¬äºŒä¸ªå›¾æ ‡
          const prevRow = this.selectedTile.row;
          const prevCol = this.selectedTile.col;
          
          if (prevRow === row && prevCol === col) {
            // ç‚¹å‡»åŒä¸€ä¸ªå›¾æ ‡ï¼Œå–æ¶ˆé€‰æ‹©
            this.grid[prevRow][prevCol].element.classList.remove('selected');
            this.selectedTile = null;
            this.showMessage('å–æ¶ˆé€‰æ‹©');
            return;
          }
          
          // æ£€æŸ¥æ˜¯å¦å¯ä»¥åŒ¹é…
          if (this.canMatch(prevRow, prevCol, row, col)) {
            // åŒ¹é…æˆåŠŸ
            this.grid[prevRow][prevCol].matched = true;
            this.grid[row][col].matched = true;
            
            this.grid[prevRow][prevCol].element.classList.add('matched');
            this.grid[row][col].element.classList.add('matched');
            
            this.grid[prevRow][prevCol].element.classList.remove('selected');
            this.selectedTile = null;
            
            this.pairsFound++;
            this.moves++;
            this.updateStats();
            
            this.showMessage('åŒ¹é…æˆåŠŸï¼');
            
            // æ£€æŸ¥æ˜¯å¦è·èƒœ
            if (this.pairsFound === this.totalPairs) {
              this.endGame(true);
            }
          } else {
            // åŒ¹é…å¤±è´¥
            this.showMessage('æ— æ³•åŒ¹é…ï¼Œè¯·é€‰æ‹©è·¯å¾„ä¸Šæ‹è§’ä¸è¶…è¿‡2ä¸ªçš„å›¾æ ‡');
          }
        }
      }
      
      canMatch(row1, col1, row2, col2) {
        // æ£€æŸ¥å›¾æ ‡æ˜¯å¦ç›¸åŒ
        if (this.grid[row1][col1].value !== this.grid[row2][col2].value) {
          return false;
        }
        
        // ä¸èƒ½é€‰æ‹©åŒä¸€ä¸ªä½ç½®
        if (row1 === row2 && col1 === col2) {
          return false;
        }
        
        // æ£€æŸ¥è·¯å¾„
        return this.checkPath(row1, col1, row2, col2);
      }
      
      checkPath(row1, col1, row2, col2) {
        // å¦‚æœåœ¨åŒä¸€è¡Œ
        if (row1 === row2) {
          return this.checkHorizontalPath(row1, col1, col2);
        }
        
        // å¦‚æœåœ¨åŒä¸€åˆ—
        if (col1 === col2) {
          return this.checkVerticalPath(col1, row1, row2);
        }
        
        // æ£€æŸ¥ä¸€ä¸ªæ‹è§’çš„è·¯å¾„
        if (this.isValidCornerPath(row1, col1, row2, col2)) {
          return true;
        }
        
        // æ£€æŸ¥ä¸¤ä¸ªæ‹è§’çš„è·¯å¾„
        if (this.isValidTwoCornerPath(row1, col1, row2, col2)) {
          return true;
        }
        
        return false;
      }
      
      checkHorizontalPath(row, col1, col2) {
        const start = Math.min(col1, col2);
        const end = Math.max(col1, col2);
        
        for (let col = start + 1; col < end; col++) {
          if (!this.grid[row][col].matched) {
            return false;
          }
        }
        return true;
      }
      
      checkVerticalPath(col, row1, row2) {
        const start = Math.min(row1, row2);
        const end = Math.max(row1, row2);
        
        for (let row = start + 1; row < end; row++) {
          if (!this.grid[row][col].matched) {
            return false;
          }
        }
        return true;
      }
      
      isValidCornerPath(row1, col1, row2, col2) {
        // é€šè¿‡ä¸€ä¸ªæ‹è§’è¿æ¥ (row1, col1) -> (row1, col2) -> (row2, col2)
        if (this.grid[row1][col2].matched && 
            this.checkHorizontalPath(row1, Math.min(col1, col2), Math.max(col1, col2)) &&
            this.checkVerticalPath(col2, Math.min(row1, row2), Math.max(row1, row2))) {
          return true;
        }
        
        // é€šè¿‡ä¸€ä¸ªæ‹è§’è¿æ¥ (row1, col1) -> (row2, col1) -> (row2, col2)
        if (this.grid[row2][col1].matched && 
            this.checkVerticalPath(col1, Math.min(row1, row2), Math.max(row1, row2)) &&
            this.checkHorizontalPath(row2, Math.min(col1, col2), Math.max(col1, col2))) {
          return true;
        }
        
        return false;
      }
      
      isValidTwoCornerPath(row1, col1, row2, col2) {
        // æ£€æŸ¥ä¸¤ä¸ªæ‹è§’çš„è·¯å¾„
        // ä» (row1, col1) åˆ° (row1, x) åˆ° (row2, x) åˆ° (row2, col2)
        for (let x = 0; x < this.boardSize; x++) {
          if (x !== col1 && x !== col2 && this.grid[row1][x].matched && this.grid[row2][x].matched) {
            if (this.checkHorizontalPath(row1, Math.min(col1, x), Math.max(col1, x)) &&
                this.checkHorizontalPath(row2, Math.min(col2, x), Math.max(col2, x)) &&
                this.checkVerticalPath(x, Math.min(row1, row2), Math.max(row1, row2))) {
              return true;
            }
          }
        }
        
        // ä» (row1, col1) åˆ° (x, col1) åˆ° (x, col2) åˆ° (row2, col2)
        for (let x = 0; x < this.boardSize; x++) {
          if (x !== row1 && x !== row2 && this.grid[x][col1].matched && this.grid[x][col2].matched) {
            if (this.checkVerticalPath(col1, Math.min(row1, x), Math.max(row1, x)) &&
                this.checkVerticalPath(col2, Math.min(row2, x), Math.max(row2, x)) &&
                this.checkHorizontalPath(x, Math.min(col1, col2), Math.max(col1, col2))) {
              return true;
            }
          }
        }
        
        return false;
      }
      
      showMessage(text) {
        const messageEl = document.getElementById('message');
        messageEl.textContent = text;
        messageEl.classList.remove('win-message');
      }
      
      showWinMessage() {
        const messageEl = document.getElementById('message');
        messageEl.textContent = `æ­å–œè·èƒœï¼ç”¨æ—¶ ${this.time} ç§’ï¼Œå…± ${this.moves} æ­¥`;
        messageEl.classList.add('win-message');
      }
      
      startTimer() {
        this.timerInterval = setInterval(() => {
          this.time++;
          this.updateStats();
        }, 1000);
      }
      
      stopTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      }
      
      endGame(isWin) {
        this.stopTimer();
        if (isWin) {
          this.showWinMessage();
        }
      }
      
      resetGame() {
        this.stopTimer();
        this.selectedTile = null;
        this.moves = 0;
        this.time = 0;
        this.pairsFound = 0;
        this.gameStarted = false;
        this.createBoard();
        this.updateStats();
        this.showMessage('é€‰æ‹©ä¸¤ä¸ªç›¸åŒçš„å›¾æ ‡è¿›è¡Œæ¶ˆé™¤');
      }
      
      giveHint() {
        // ç®€å•çš„æç¤ºï¼šæ‰¾å‡ºä¸€ç»„å¯ä»¥åŒ¹é…çš„å›¾æ ‡
        for (let row1 = 0; row1 < this.boardSize; row1++) {
          for (let col1 = 0; col1 < this.boardSize; col1++) {
            if (this.grid[row1][col1].matched) continue;
            
            for (let row2 = row1; row2 < this.boardSize; row2++) {
              const startCol = (row1 === row2) ? col1 + 1 : 0;
              for (let col2 = startCol; col2 < this.boardSize; col2++) {
                if (this.grid[row2][col2].matched) continue;
                
                if (this.canMatch(row1, col1, row2, col2)) {
                  // é«˜äº®è¿™ä¸¤ä¸ªå›¾æ ‡
                  this.grid[row1][col1].element.style.boxShadow = '0 0 0 3px #FFD700, 0 6px 8px rgba(0, 0, 0, 0.15)';
                  this.grid[row2][col2].element.style.boxShadow = '0 0 0 3px #FFD700, 0 6px 8px rgba(0, 0, 0, 0.15)';
                  
                  // 2ç§’åç§»é™¤é«˜äº®
                  setTimeout(() => {
                    this.grid[row1][col1].element.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                    this.grid[row2][col2].element.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                  }, 2000);
                  
                  this.showMessage('æç¤ºï¼šå·²é«˜äº®ä¸€ç»„å¯åŒ¹é…çš„å›¾æ ‡');
                  return;
                }
              }
            }
          }
        }
        this.showMessage('æ²¡æœ‰æ‰¾åˆ°å¯åŒ¹é…çš„å›¾æ ‡');
      }
      
      updateStats() {
        document.getElementById('moves').textContent = this.moves;
        document.getElementById('time').textContent = this.time + 's';
        document.getElementById('pairs').textContent = this.pairsFound;
      }
      
      setupEventListeners() {
        document.getElementById('restartBtn').addEventListener('click', () => {
          this.resetGame();
        });
        
        document.getElementById('hintBtn').addEventListener('click', () => {
          this.giveHint();
        });
      }
    }
    
    // å¯åŠ¨æ¸¸æˆ
    window.addEventListener('DOMContentLoaded', () => {
      new LinkGame();
    });
  </script>
</body>
</html>